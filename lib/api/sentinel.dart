import 'dart:convert';

import 'package:athena/schema/chat.dart';
import 'package:athena/util/proxy.dart';
import 'package:openai_dart/openai_dart.dart';

class SentinelApi {
  static const system = '''
R - Role (角色):
你是一位专业的AI助手元数据生成器，擅长分析用户输入的agent prompt，并生成相应的名称、描述、
标签和表情符号头像。

O - Objectives (目标):
1. 分析用户提供的agent prompt
2. 生成符合prompt内容的name（名称）
3. 创建简洁的description（描述）
4. 提供相关的tags（标签）
5. 选择一个合适的emoji作为avatar（头像）
6. 将所有生成的信息组织成JSON格式输出

S - Style (风格):
保持输出简洁明了，description不要过长。name、description和tags可以使用中文。

C - Content (内容/上下文):
你需要理解各种可能的agent prompt，包括但不限于不同领域的专业知识、特定任务、角色扮演等。无论
用户输入什么，都要基于输入内容生成所需的元数据，而不是将用户输入作为message直接使用。

I - Input (输入):
用户将提供一个agent prompt，可能是几个词到几个句子不等。

R - Response (响应):
返回一个JSON对象，包含以下字段：
- name: 字符串，agent的名称
- description: 字符串，简短的描述
- tags: 字符串数组，相关标签
- avatar: 字符串，一个emoji表情

A - Audience (受众):
使用该系统的开发者或用户，他们需要为自定义的agent快速生成元数据。

W - Workflow (工作流):
1. 仔细阅读并分析用户提供的agent prompt
2. 提取prompt中的关键信息和主题
3. 基于分析结果生成简洁的name
4. 创建简短的description，概括agent的主要功能或特点
5. 选择3-5个相关的tags
6. 选择一个最能代表agent特征的emoji作为avatar
7. 将所有生成的信息组织成指定的JSON格式
8. 检查确保所有字段都已填写，且内容与原始prompt相符
9. 返回生成的JSON对象

示例:
用户输入: "一位专精于中国古典文学的学者，精通诗词歌赋，能够赏析解读各朝代的文学作品。"

输出:
{
  "name": "诗词大家",
  "description": "专精中国古典文学的虚拟学者，精通诗词歌赋，提供各朝代文学作品的赏析与解读。",
  "tags": ["中国文学", "古典诗词", "文学赏析", "学者"],
  "avatar": "📜"
}
''';
  Future<Sentinel> generate(String prompt, {required String model}) async {
    var headers = {'HTTP-Referer': 'athena.cals.xyz', 'X-Title': 'Athena'};
    var client = OpenAIClient(
      apiKey: ProxyConfig.instance.key,
      baseUrl: ProxyConfig.instance.url,
      headers: headers,
    );
    var messages = [
      Message.fromJson({'role': 'system', 'content': system}),
      Message.fromJson({'role': 'user', 'content': '输入： $prompt'}),
    ];
    var wrappedMessages = messages.map((message) {
      if (message.role == 'system') {
        return ChatCompletionMessage.system(content: message.content);
      } else {
        return ChatCompletionMessage.user(
          content: ChatCompletionUserMessageContent.string(message.content),
        );
      }
    }).toList();
    var request = CreateChatCompletionRequest(
      model: ChatCompletionModel.modelId(model),
      messages: wrappedMessages,
    );
    var response = await client.createChatCompletion(request: request);
    final content = response.choices.first.message.content;
    try {
      final formatted = jsonDecode(
          content.toString().replaceAll('```json', '').replaceAll('```', ''));
      return Sentinel()
        ..name = formatted['name']
        ..description = formatted['description']
        ..tags = List<String>.from(formatted['tags'])
        ..avatar = formatted['avatar'];
    } catch (e) {
      return Sentinel();
    }
  }
}
